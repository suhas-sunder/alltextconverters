type AllowedTag =
  | "DIV"
  | "P"
  | "BR"
  | "SPAN"
  | "B"
  | "STRONG"
  | "I"
  | "EM"
  | "U"
  | "UL"
  | "OL"
  | "LI"
  | "H1"
  | "H2"
  | "H3"
  | "H4"
  | "H5"
  | "TABLE"
  | "THEAD"
  | "TBODY"
  | "TR"
  | "TH"
  | "TD"
  | "A";

const ALLOWED_TAGS = new Set<AllowedTag>([
  "DIV",
  "P",
  "BR",
  "SPAN",
  "B",
  "STRONG",
  "I",
  "EM",
  "U",
  "UL",
  "OL",
  "LI",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "TABLE",
  "THEAD",
  "TBODY",
  "TR",
  "TH",
  "TD",
  "A",
]);

// Keep a small, predictable subset of CSS if present.
// This helps preserve basic spacing and emphasis without pretending perfect fidelity.
const STYLE_ALLOWLIST = new Set([
  "font-weight",
  "font-style",
  "text-decoration",
  "text-align",
  "font-size",
  "font-family",
  "line-height",
  "color",
]);

function filterStyle(styleAttr: string): string {
  const parts = styleAttr
    .split(";")
    .map((p) => p.trim())
    .filter(Boolean);

  const kept: string[] = [];
  for (const part of parts) {
    const idx = part.indexOf(":");
    if (idx === -1) continue;
    const prop = part.slice(0, idx).trim().toLowerCase();
    const val = part.slice(idx + 1).trim();
    if (!STYLE_ALLOWLIST.has(prop)) continue;
    // block obvious CSS injection patterns
    if (/url\(|expression\(|javascript:/i.test(val)) continue;
    kept.push(`${prop}: ${val}`);
  }
  return kept.join("; ");
}

export function sanitizeRichHtml(inputHtml: string): string {
  if (typeof window === "undefined") return inputHtml;

  const parser = new DOMParser();
  const doc = parser.parseFromString(inputHtml || "", "text/html");
  const body = doc.body;

  const walk = (node: Node) => {
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node as HTMLElement;

      if (!ALLOWED_TAGS.has(el.tagName as AllowedTag)) {
        // Replace disallowed nodes with their children (keeps text).
        const parent = el.parentNode;
        if (!parent) return;
        while (el.firstChild) parent.insertBefore(el.firstChild, el);
        parent.removeChild(el);
        return;
      }

      // Strip event handlers and risky attributes.
      for (const attr of Array.from(el.attributes)) {
        const name = attr.name.toLowerCase();
        if (name.startsWith("on")) el.removeAttribute(attr.name);
      }

      // Keep only safe style subset
      if (el.hasAttribute("style")) {
        const filtered = filterStyle(el.getAttribute("style") || "");
        if (filtered) el.setAttribute("style", filtered);
        else el.removeAttribute("style");
      }

      // Allow safe links (<a href="...">) and strip everything else.
      if (el.tagName === "A") {
        const href = el.getAttribute("href") || "";
        const safe = href.trim();
        const ok =
          /^https?:\/\//i.test(safe) ||
          /^mailto:/i.test(safe) ||
          /^tel:/i.test(safe) ||
          safe.startsWith("#");
        if (!ok) el.removeAttribute("href");
        else {
          el.setAttribute("href", safe);
          // Always open external links safely when exported
          if (!safe.startsWith("#")) {
            el.setAttribute("target", "_blank");
            el.setAttribute("rel", "noopener noreferrer");
          }
        }
      } else if (el.hasAttribute("href")) {
        el.removeAttribute("href");
      }
      if (el.hasAttribute("src")) el.removeAttribute("src");
    }

    for (const child of Array.from(node.childNodes)) {
      walk(child);
    }
  };

  // IMPORTANT:
  // Do NOT sanitize/remove the <body> element itself.
  // DOMParser wraps input in <html><head>…</head><body>…</body></html>.
  // If we treat BODY as a normal node and strip it (not in allowlist), we'd
  // move its children out and then remove it, which empties body.innerHTML.
  // That breaks typing/pasting because every input sanitizes to "".
  for (const child of Array.from(body.childNodes)) {
    walk(child);
  }

  // Remove empty wrappers generated by pasted content
  return body.innerHTML.trim();
}
